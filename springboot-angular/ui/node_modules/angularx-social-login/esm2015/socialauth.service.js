import { Inject, Injectable } from '@angular/core';
import { AsyncSubject, ReplaySubject } from 'rxjs';
import { GoogleLoginProvider } from './providers/google-login-provider';
import * as i0 from "@angular/core";
/**
 * The service encapsulating the social login functionality. Exposes methods like
 * `signIn`, `signOut`. Also, exposes an `authState` `Observable` that one can
 * subscribe to get the current logged in user information.
 *
 * @dynamic
 */
export class SocialAuthService {
    /**
     * @param config A `SocialAuthServiceConfig` object or a `Promise` that resolves to a `SocialAuthServiceConfig` object
     */
    constructor(config) {
        this.providers = new Map();
        this.autoLogin = false;
        this._user = null;
        this._authState = new ReplaySubject(1);
        /* Consider making this an enum comprising LOADING, LOADED, FAILED etc. */
        this.initialized = false;
        this._initState = new AsyncSubject();
        if (config instanceof Promise) {
            config.then((config) => {
                this.initialize(config);
            });
        }
        else {
            this.initialize(config);
        }
    }
    /** An `Observable` that one can subscribe to get the current logged in user information */
    get authState() {
        return this._authState.asObservable();
    }
    /** An `Observable` to communicate the readiness of the service and associated login providers */
    get initState() {
        return this._initState.asObservable();
    }
    initialize(config) {
        this.autoLogin = config.autoLogin !== undefined ? config.autoLogin : false;
        const { onError = console.error } = config;
        config.providers.forEach((item) => {
            this.providers.set(item.id, item.provider);
        });
        Promise.all(Array.from(this.providers.values()).map((provider) => provider.initialize()))
            .then(() => {
            if (this.autoLogin) {
                const loginStatusPromises = [];
                let loggedIn = false;
                this.providers.forEach((provider, key) => {
                    let promise = provider.getLoginStatus();
                    loginStatusPromises.push(promise);
                    promise
                        .then((user) => {
                        user.provider = key;
                        this._user = user;
                        this._authState.next(user);
                        loggedIn = true;
                    })
                        .catch(console.debug);
                });
                Promise.all(loginStatusPromises).catch(() => {
                    if (!loggedIn) {
                        this._user = null;
                        this._authState.next(null);
                    }
                });
            }
        })
            .catch((error) => {
            onError(error);
        })
            .finally(() => {
            this.initialized = true;
            this._initState.next(this.initialized);
            this._initState.complete();
        });
    }
    refreshAuthToken(providerId) {
        return new Promise((resolve, reject) => {
            if (!this.initialized) {
                reject(SocialAuthService.ERR_NOT_INITIALIZED);
            }
            else if (providerId !== GoogleLoginProvider.PROVIDER_ID) {
                reject(SocialAuthService.ERR_NOT_SUPPORTED_FOR_REFRESH_TOKEN);
            }
            else {
                const providerObject = this.providers.get(providerId);
                if (providerObject) {
                    providerObject
                        .getLoginStatus({ refreshToken: true })
                        .then((user) => {
                        user.provider = providerId;
                        this._user = user;
                        this._authState.next(user);
                        resolve();
                    })
                        .catch((err) => {
                        reject(err);
                    });
                }
                else {
                    reject(SocialAuthService.ERR_LOGIN_PROVIDER_NOT_FOUND);
                }
            }
        });
    }
    /**
     * A method used to sign in a user with a specific `LoginProvider`.
     *
     * @param providerId Id with which the `LoginProvider` has been registered with the service
     * @param signInOptions Optional `LoginProvider` specific arguments
     * @returns A `Promise` that resolves to the authenticated user information
     */
    signIn(providerId, signInOptions) {
        return new Promise((resolve, reject) => {
            if (!this.initialized) {
                reject(SocialAuthService.ERR_NOT_INITIALIZED);
            }
            else {
                let providerObject = this.providers.get(providerId);
                if (providerObject) {
                    providerObject
                        .signIn(signInOptions)
                        .then((user) => {
                        user.provider = providerId;
                        resolve(user);
                        this._user = user;
                        this._authState.next(user);
                    })
                        .catch((err) => {
                        reject(err);
                    });
                }
                else {
                    reject(SocialAuthService.ERR_LOGIN_PROVIDER_NOT_FOUND);
                }
            }
        });
    }
    /**
     * A method used to sign out the currently loggen in user.
     *
     * @param revoke Optional parameter to specify whether a hard sign out is to be performed
     * @returns A `Promise` that resolves if the operation is successful, rejects otherwise
     */
    signOut(revoke = false) {
        return new Promise((resolve, reject) => {
            if (!this.initialized) {
                reject(SocialAuthService.ERR_NOT_INITIALIZED);
            }
            else if (!this._user) {
                reject(SocialAuthService.ERR_NOT_LOGGED_IN);
            }
            else {
                let providerId = this._user.provider;
                let providerObject = this.providers.get(providerId);
                if (providerObject) {
                    providerObject
                        .signOut(revoke)
                        .then(() => {
                        resolve();
                        this._user = null;
                        this._authState.next(null);
                    })
                        .catch((err) => {
                        reject(err);
                    });
                }
                else {
                    reject(SocialAuthService.ERR_LOGIN_PROVIDER_NOT_FOUND);
                }
            }
        });
    }
}
SocialAuthService.ERR_LOGIN_PROVIDER_NOT_FOUND = 'Login provider not found';
SocialAuthService.ERR_NOT_LOGGED_IN = 'Not logged in';
SocialAuthService.ERR_NOT_INITIALIZED = 'Login providers not ready yet. Are there errors on your console?';
SocialAuthService.ERR_NOT_SUPPORTED_FOR_REFRESH_TOKEN = 'Chosen login provider is not supported for refreshing a token';
SocialAuthService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.1", ngImport: i0, type: SocialAuthService, deps: [{ token: 'SocialAuthServiceConfig' }], target: i0.ɵɵFactoryTarget.Injectable });
SocialAuthService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.1", ngImport: i0, type: SocialAuthService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.1", ngImport: i0, type: SocialAuthService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: ['SocialAuthServiceConfig']
                }] }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic29jaWFsYXV0aC5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vcHJvamVjdHMvbGliL3NyYy9zb2NpYWxhdXRoLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLE1BQU0sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDbkQsT0FBTyxFQUFFLFlBQVksRUFBYyxhQUFhLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFHL0QsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sbUNBQW1DLENBQUM7O0FBV3hFOzs7Ozs7R0FNRztBQUVILE1BQU0sT0FBTyxpQkFBaUI7SUE2QjVCOztPQUVHO0lBQ0gsWUFFRSxNQUFrRTtRQXpCNUQsY0FBUyxHQUErQixJQUFJLEdBQUcsRUFBRSxDQUFDO1FBQ2xELGNBQVMsR0FBRyxLQUFLLENBQUM7UUFFbEIsVUFBSyxHQUFlLElBQUksQ0FBQztRQUN6QixlQUFVLEdBQThCLElBQUksYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRXJFLDBFQUEwRTtRQUNsRSxnQkFBVyxHQUFHLEtBQUssQ0FBQztRQUNwQixlQUFVLEdBQTBCLElBQUksWUFBWSxFQUFFLENBQUM7UUFtQjdELElBQUksTUFBTSxZQUFZLE9BQU8sRUFBRTtZQUM3QixNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxFQUFFLEVBQUU7Z0JBQ3JCLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDMUIsQ0FBQyxDQUFDLENBQUM7U0FDSjthQUFNO1lBQ0wsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQztTQUN6QjtJQUNILENBQUM7SUF4QkQsMkZBQTJGO0lBQzNGLElBQUksU0FBUztRQUNYLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxZQUFZLEVBQUUsQ0FBQztJQUN4QyxDQUFDO0lBRUQsaUdBQWlHO0lBQ2pHLElBQUksU0FBUztRQUNYLE9B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SSxDQUFDLEdBQUcsRUFBRTt3QkFDVCxPQUFPLEVBQUUsQ0FBQzt3QkFFVixJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQzt3QkFDbEIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7b0JBQzdCLENBQUMsQ0FBQzt5QkFDRCxLQUFLLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRTt3QkFDYixNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7b0JBQ2QsQ0FBQyxDQUFDLENBQUM7aUJBQ047cUJBQU07b0JBQ0wsTUFBTSxDQUFDLGlCQUFpQixDQUFDLDRCQUE0QixDQUFDLENBQUM7aUJBQ3hEO2FBQ0Y7UUFDSCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7O0FBekx1Qiw4Q0FBNEIsR0FDbEQsMEJBQTBCLENBQUM7QUFDTCxtQ0FBaUIsR0FBRyxlQUFlLENBQUM7QUFDcEMscUNBQW1CLEdBQ3pDLGtFQUFrRSxDQUFDO0FBQzdDLHFEQUFtQyxHQUN6RCwrREFBK0QsQ0FBQzs4R0FQdkQsaUJBQWlCLGtCQWlDbEIseUJBQXlCO2tIQWpDeEIsaUJBQWlCOzJGQUFqQixpQkFBaUI7a0JBRDdCLFVBQVU7OzBCQWtDTixNQUFNOzJCQUFDLHlCQUF5QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdCwgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQXN5bmNTdWJqZWN0LCBPYnNlcnZhYmxlLCBSZXBsYXlTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBMb2dpblByb3ZpZGVyIH0gZnJvbSAnLi9lbnRpdGllcy9sb2dpbi1wcm92aWRlcic7XG5pbXBvcnQgeyBTb2NpYWxVc2VyIH0gZnJvbSAnLi9lbnRpdGllcy9zb2NpYWwtdXNlcic7XG5pbXBvcnQgeyBHb29nbGVMb2dpblByb3ZpZGVyIH0gZnJvbSAnLi9wcm92aWRlcnMvZ29vZ2xlLWxvZ2luLXByb3ZpZGVyJztcblxuLyoqXG4gKiBBbiBpbnRlcmZhY2UgdG8gZGVmaW5lIHRoZSBzaGFwZSBvZiB0aGUgc2VydmljZSBjb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU29jaWFsQXV0aFNlcnZpY2VDb25maWcge1xuICBhdXRvTG9naW4/OiBib29sZWFuO1xuICBwcm92aWRlcnM6IHsgaWQ6IHN0cmluZzsgcHJvdmlkZXI6IExvZ2luUHJvdmlkZXIgfVtdO1xuICBvbkVycm9yPzogKGVycm9yOiBhbnkpID0+IGFueTtcbn1cblxuLyoqXG4gKiBUaGUgc2VydmljZSBlbmNhcHN1bGF0aW5nIHRoZSBzb2NpYWwgbG9naW4gZnVuY3Rpb25hbGl0eS4gRXhwb3NlcyBtZXRob2RzIGxpa2VcbiAqIGBzaWduSW5gLCBgc2lnbk91dGAuIEFsc28sIGV4cG9zZXMgYW4gYGF1dGhTdGF0ZWAgYE9ic2VydmFibGVgIHRoYXQgb25lIGNhblxuICogc3Vic2NyaWJlIHRvIGdldCB0aGUgY3VycmVudCBsb2dnZWQgaW4gdXNlciBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAZHluYW1pY1xuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgU29jaWFsQXV0aFNlcnZpY2Uge1xuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBFUlJfTE9HSU5fUFJPVklERVJfTk9UX0ZPVU5EID1cbiAgICAnTG9naW4gcHJvdmlkZXIgbm90IGZvdW5kJztcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgRVJSX05PVF9MT0dHRURfSU4gPSAnTm90IGxvZ2dlZCBpbic7XG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IEVSUl9OT1RfSU5JVElBTElaRUQgPVxuICAgICdMb2dpbiBwcm92aWRlcnMgbm90IHJlYWR5IHlldC4gQXJlIHRoZXJlIGVycm9ycyBvbiB5b3VyIGNvbnNvbGU/JztcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgRVJSX05PVF9TVVBQT1JURURfRk9SX1JFRlJFU0hfVE9LRU4gPVxuICAgICdDaG9zZW4gbG9naW4gcHJvdmlkZXIgaXMgbm90IHN1cHBvcnRlZCBmb3IgcmVmcmVzaGluZyBhIHRva2VuJztcblxuICBwcml2YXRlIHByb3ZpZGVyczogTWFwPHN0cmluZywgTG9naW5Qcm92aWRlcj4gPSBuZXcgTWFwKCk7XG4gIHByaXZhdGUgYXV0b0xvZ2luID0gZmFsc2U7XG5cbiAgcHJpdmF0ZSBfdXNlcjogU29jaWFsVXNlciA9IG51bGw7XG4gIHByaXZhdGUgX2F1dGhTdGF0ZTogUmVwbGF5U3ViamVjdDxTb2NpYWxVc2VyPiA9IG5ldyBSZXBsYXlTdWJqZWN0KDEpO1xuXG4gIC8qIENvbnNpZGVyIG1ha2luZyB0aGlzIGFuIGVudW0gY29tcHJpc2luZyBMT0FESU5HLCBMT0FERUQsIEZBSUxFRCBldGMuICovXG4gIHByaXZhdGUgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgcHJpdmF0ZSBfaW5pdFN0YXRlOiBBc3luY1N1YmplY3Q8Ym9vbGVhbj4gPSBuZXcgQXN5bmNTdWJqZWN0KCk7XG5cbiAgLyoqIEFuIGBPYnNlcnZhYmxlYCB0aGF0IG9uZSBjYW4gc3Vic2NyaWJlIHRvIGdldCB0aGUgY3VycmVudCBsb2dnZWQgaW4gdXNlciBpbmZvcm1hdGlvbiAqL1xuICBnZXQgYXV0aFN0YXRlKCk6IE9ic2VydmFibGU8U29jaWFsVXNlcj4ge1xuICAgIHJldHVybiB0aGlzLl9hdXRoU3RhdGUuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICAvKiogQW4gYE9ic2VydmFibGVgIHRvIGNvbW11bmljYXRlIHRoZSByZWFkaW5lc3Mgb2YgdGhlIHNlcnZpY2UgYW5kIGFzc29jaWF0ZWQgbG9naW4gcHJvdmlkZXJzICovXG4gIGdldCBpbml0U3RhdGUoKTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XG4gICAgcmV0dXJuIHRoaXMuX2luaXRTdGF0ZS5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gY29uZmlnIEEgYFNvY2lhbEF1dGhTZXJ2aWNlQ29uZmlnYCBvYmplY3Qgb3IgYSBgUHJvbWlzZWAgdGhhdCByZXNvbHZlcyB0byBhIGBTb2NpYWxBdXRoU2VydmljZUNvbmZpZ2Agb2JqZWN0XG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBASW5qZWN0KCdTb2NpYWxBdXRoU2VydmljZUNvbmZpZycpXG4gICAgY29uZmlnOiBTb2NpYWxBdXRoU2VydmljZUNvbmZpZyB8IFByb21pc2U8U29jaWFsQXV0aFNlcnZpY2VDb25maWc+XG4gICkge1xuICAgIGlmIChjb25maWcgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICBjb25maWcudGhlbigoY29uZmlnKSA9PiB7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZShjb25maWcpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZShjb25maWcpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgaW5pdGlhbGl6ZShjb25maWc6IFNvY2lhbEF1dGhTZXJ2aWNlQ29uZmlnKSB7XG4gICAgdGhpcy5hdXRvTG9naW4gPSBjb25maWcuYXV0b0xvZ2luICE9PSB1bmRlZmluZWQgPyBjb25maWcuYXV0b0xvZ2luIDogZmFsc2U7XG4gICAgY29uc3QgeyBvbkVycm9yID0gY29uc29sZS5lcnJvciB9ID0gY29uZmlnO1xuXG4gICAgY29uZmlnLnByb3ZpZGVycy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICB0aGlzLnByb3ZpZGVycy5zZXQoaXRlbS5pZCwgaXRlbS5wcm92aWRlcik7XG4gICAgfSk7XG5cbiAgICBQcm9taXNlLmFsbChcbiAgICAgIEFycmF5LmZyb20odGhpcy5wcm92aWRlcnMudmFsdWVzKCkpLm1hcCgocHJvdmlkZXIpID0+XG4gICAgICAgIHByb3ZpZGVyLmluaXRpYWxpemUoKVxuICAgICAgKVxuICAgIClcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuYXV0b0xvZ2luKSB7XG4gICAgICAgICAgY29uc3QgbG9naW5TdGF0dXNQcm9taXNlcyA9IFtdO1xuICAgICAgICAgIGxldCBsb2dnZWRJbiA9IGZhbHNlO1xuXG4gICAgICAgICAgdGhpcy5wcm92aWRlcnMuZm9yRWFjaCgocHJvdmlkZXI6IExvZ2luUHJvdmlkZXIsIGtleTogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICBsZXQgcHJvbWlzZSA9IHByb3ZpZGVyLmdldExvZ2luU3RhdHVzKCk7XG4gICAgICAgICAgICBsb2dpblN0YXR1c1Byb21pc2VzLnB1c2gocHJvbWlzZSk7XG4gICAgICAgICAgICBwcm9taXNlXG4gICAgICAgICAgICAgIC50aGVuKCh1c2VyOiBTb2NpYWxVc2VyKSA9PiB7XG4gICAgICAgICAgICAgICAgdXNlci5wcm92aWRlciA9IGtleTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3VzZXIgPSB1c2VyO1xuICAgICAgICAgICAgICAgIHRoaXMuX2F1dGhTdGF0ZS5uZXh0KHVzZXIpO1xuICAgICAgICAgICAgICAgIGxvZ2dlZEluID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgLmNhdGNoKGNvbnNvbGUuZGVidWcpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIFByb21pc2UuYWxsKGxvZ2luU3RhdHVzUHJvbWlzZXMpLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgIGlmICghbG9nZ2VkSW4pIHtcbiAgICAgICAgICAgICAgdGhpcy5fdXNlciA9IG51bGw7XG4gICAgICAgICAgICAgIHRoaXMuX2F1dGhTdGF0ZS5uZXh0KG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICBvbkVycm9yKGVycm9yKTtcbiAgICAgIH0pXG4gICAgICAuZmluYWxseSgoKSA9PiB7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9pbml0U3RhdGUubmV4dCh0aGlzLmluaXRpYWxpemVkKTtcbiAgICAgICAgdGhpcy5faW5pdFN0YXRlLmNvbXBsZXRlKCk7XG4gICAgICB9KTtcbiAgfVxuXG4gIHJlZnJlc2hBdXRoVG9rZW4ocHJvdmlkZXJJZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmICghdGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgICByZWplY3QoU29jaWFsQXV0aFNlcnZpY2UuRVJSX05PVF9JTklUSUFMSVpFRCk7XG4gICAgICB9IGVsc2UgaWYgKHByb3ZpZGVySWQgIT09IEdvb2dsZUxvZ2luUHJvdmlkZXIuUFJPVklERVJfSUQpIHtcbiAgICAgICAgcmVqZWN0KFNvY2lhbEF1dGhTZXJ2aWNlLkVSUl9OT1RfU1VQUE9SVEVEX0ZPUl9SRUZSRVNIX1RPS0VOKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyT2JqZWN0ID0gdGhpcy5wcm92aWRlcnMuZ2V0KHByb3ZpZGVySWQpO1xuICAgICAgICBpZiAocHJvdmlkZXJPYmplY3QpIHtcbiAgICAgICAgICBwcm92aWRlck9iamVjdFxuICAgICAgICAgICAgLmdldExvZ2luU3RhdHVzKHsgcmVmcmVzaFRva2VuOiB0cnVlIH0pXG4gICAgICAgICAgICAudGhlbigodXNlcjogU29jaWFsVXNlcikgPT4ge1xuICAgICAgICAgICAgICB1c2VyLnByb3ZpZGVyID0gcHJvdmlkZXJJZDtcbiAgICAgICAgICAgICAgdGhpcy5fdXNlciA9IHVzZXI7XG4gICAgICAgICAgICAgIHRoaXMuX2F1dGhTdGF0ZS5uZXh0KHVzZXIpO1xuICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWplY3QoU29jaWFsQXV0aFNlcnZpY2UuRVJSX0xPR0lOX1BST1ZJREVSX05PVF9GT1VORCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIG1ldGhvZCB1c2VkIHRvIHNpZ24gaW4gYSB1c2VyIHdpdGggYSBzcGVjaWZpYyBgTG9naW5Qcm92aWRlcmAuXG4gICAqXG4gICAqIEBwYXJhbSBwcm92aWRlcklkIElkIHdpdGggd2hpY2ggdGhlIGBMb2dpblByb3ZpZGVyYCBoYXMgYmVlbiByZWdpc3RlcmVkIHdpdGggdGhlIHNlcnZpY2VcbiAgICogQHBhcmFtIHNpZ25Jbk9wdGlvbnMgT3B0aW9uYWwgYExvZ2luUHJvdmlkZXJgIHNwZWNpZmljIGFyZ3VtZW50c1xuICAgKiBAcmV0dXJucyBBIGBQcm9taXNlYCB0aGF0IHJlc29sdmVzIHRvIHRoZSBhdXRoZW50aWNhdGVkIHVzZXIgaW5mb3JtYXRpb25cbiAgICovXG4gIHNpZ25Jbihwcm92aWRlcklkOiBzdHJpbmcsIHNpZ25Jbk9wdGlvbnM/OiBhbnkpOiBQcm9taXNlPFNvY2lhbFVzZXI+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICAgIHJlamVjdChTb2NpYWxBdXRoU2VydmljZS5FUlJfTk9UX0lOSVRJQUxJWkVEKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBwcm92aWRlck9iamVjdCA9IHRoaXMucHJvdmlkZXJzLmdldChwcm92aWRlcklkKTtcbiAgICAgICAgaWYgKHByb3ZpZGVyT2JqZWN0KSB7XG4gICAgICAgICAgcHJvdmlkZXJPYmplY3RcbiAgICAgICAgICAgIC5zaWduSW4oc2lnbkluT3B0aW9ucylcbiAgICAgICAgICAgIC50aGVuKCh1c2VyOiBTb2NpYWxVc2VyKSA9PiB7XG4gICAgICAgICAgICAgIHVzZXIucHJvdmlkZXIgPSBwcm92aWRlcklkO1xuICAgICAgICAgICAgICByZXNvbHZlKHVzZXIpO1xuXG4gICAgICAgICAgICAgIHRoaXMuX3VzZXIgPSB1c2VyO1xuICAgICAgICAgICAgICB0aGlzLl9hdXRoU3RhdGUubmV4dCh1c2VyKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlamVjdChTb2NpYWxBdXRoU2VydmljZS5FUlJfTE9HSU5fUFJPVklERVJfTk9UX0ZPVU5EKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgbWV0aG9kIHVzZWQgdG8gc2lnbiBvdXQgdGhlIGN1cnJlbnRseSBsb2dnZW4gaW4gdXNlci5cbiAgICpcbiAgICogQHBhcmFtIHJldm9rZSBPcHRpb25hbCBwYXJhbWV0ZXIgdG8gc3BlY2lmeSB3aGV0aGVyIGEgaGFyZCBzaWduIG91dCBpcyB0byBiZSBwZXJmb3JtZWRcbiAgICogQHJldHVybnMgQSBgUHJvbWlzZWAgdGhhdCByZXNvbHZlcyBpZiB0aGUgb3BlcmF0aW9uIGlzIHN1Y2Nlc3NmdWwsIHJlamVjdHMgb3RoZXJ3aXNlXG4gICAqL1xuICBzaWduT3V0KHJldm9rZTogYm9vbGVhbiA9IGZhbHNlKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmICghdGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgICByZWplY3QoU29jaWFsQXV0aFNlcnZpY2UuRVJSX05PVF9JTklUSUFMSVpFRCk7XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLl91c2VyKSB7XG4gICAgICAgIHJlamVjdChTb2NpYWxBdXRoU2VydmljZS5FUlJfTk9UX0xPR0dFRF9JTik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgcHJvdmlkZXJJZCA9IHRoaXMuX3VzZXIucHJvdmlkZXI7XG4gICAgICAgIGxldCBwcm92aWRlck9iamVjdCA9IHRoaXMucHJvdmlkZXJzLmdldChwcm92aWRlcklkKTtcbiAgICAgICAgaWYgKHByb3ZpZGVyT2JqZWN0KSB7XG4gICAgICAgICAgcHJvdmlkZXJPYmplY3RcbiAgICAgICAgICAgIC5zaWduT3V0KHJldm9rZSlcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuXG4gICAgICAgICAgICAgIHRoaXMuX3VzZXIgPSBudWxsO1xuICAgICAgICAgICAgICB0aGlzLl9hdXRoU3RhdGUubmV4dChudWxsKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlamVjdChTb2NpYWxBdXRoU2VydmljZS5FUlJfTE9HSU5fUFJPVklERVJfTk9UX0ZPVU5EKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG4iXX0=